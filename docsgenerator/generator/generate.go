package generator

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

const (
	ReadmeFileName         = "README.md"
	CommandReadmeTemplate  = "<!--- This file is autogenerated from the files in docsgenerator/templates/%s --->\n&larr; [back to Commands](../README.md)\n\n# `om %s`\n\n%s\n\n## Command Usage\n```\n%s```\n\n%s"
	DescriptionFileName    = "EXPANDED_DESCRIPTION.md"
	DescriptionTemplate    = "<!--- Anything in this file will be used instead of the default command description in the final docs/%s/README.md file --->"
	AdditionalInfoFileName = "ADDITIONAL_INFO.md"
	AdditionalInfoTemplate = "<!--- Anything in this file will be appended to the final docs/%s/README.md file --->"
)

//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 -generate
//counterfeiter:generate -o ../fakes/executor.go --fake-name Executor . executor
type executor interface {
	GetCommandHelp(commandName string) ([]byte, error)
	GetCommandNames() ([]string, error)
	GetDescription(commandName string) (string, error)
	RunOmCommand(args ...string) ([]byte, error)
}

type Generator struct {
	templatesDir string
	docsDir      string
	executor     executor
}

func NewGenerator(templatesDir string, docsDir string, executor executor) Generator {
	return Generator{
		templatesDir: templatesDir,
		docsDir:      docsDir,
		executor:     executor,
	}
}

func (g *Generator) GenerateDocs() error {
	commandNames, err := g.executor.GetCommandNames()
	if err != nil {
		return err
	}

	err = g.createTemplateDirs(commandNames)
	if err != nil {
		return err
	}

	templateDirs, err := g.getTemplatesDirectoryContents(true)
	if err != nil {
		return err
	}

	for _, templateDir := range templateDirs {
		commandName := filepath.Base(templateDir)

		descriptionContents, err := getFileContents(filepath.Join(templateDir, DescriptionFileName))
		if err != nil {
			return err
		}

		additionalInfoContents, err := getFileContents(filepath.Join(templateDir, AdditionalInfoFileName))
		if err != nil {
			return err
		}

		err = os.Mkdir(filepath.Join(g.docsDir, commandName), 0755)
		if err != nil && !strings.Contains(err.Error(), "file exists") {
			return err
		}

		f, err := os.Create(filepath.Join(g.docsDir, commandName, ReadmeFileName))
		if err != nil && !strings.Contains(err.Error(), "file exists") {
			return err
		}

		if len(strings.Split(descriptionContents, "\n")) == 1 && descriptionContents == fmt.Sprintf(DescriptionTemplate, commandName) {
			descriptionContents, err = g.executor.GetDescription(commandName)
			if err != nil {
				return err
			}
		}

		if len(strings.Split(additionalInfoContents, "\n")) == 1 && additionalInfoContents == fmt.Sprintf(AdditionalInfoTemplate, commandName) {
			additionalInfoContents = ""
		}

		usage, err := g.executor.GetCommandHelp(commandName)
		if err != nil {
			return err
		}

		_, err = f.Write([]byte(fmt.Sprintf(CommandReadmeTemplate, commandName, commandName, descriptionContents, usage, additionalInfoContents)))
		if err != nil {
			return err
		}

		err = f.Close()
		if err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) createTemplateDirs(commands []string) error {
	templateDirs, err := g.getTemplatesDirectoryContents(true)
	if err != nil {
		return err
	}

	for _, command := range commands {
		err = os.Mkdir(filepath.Join(g.templatesDir, command), 0755)
		if err != nil {
			if strings.Contains(err.Error(), "file exists") {
				continue
			}

			return err
		}

		commandTemplateDir := filepath.Join(g.templatesDir, command)

		err := g.createCommandTemplates(command, commandTemplateDir, map[string]string{
			AdditionalInfoFileName: AdditionalInfoTemplate,
			DescriptionFileName:    DescriptionTemplate,
		})
		if err != nil {
			return err
		}

		fmt.Printf("Added %s templates at: templates/%s\n", command, command)
	}

	for _, templateDir := range templateDirs {
		var commandExists bool
		for _, command := range commands {
			if strings.Contains(templateDir, command) {
				commandExists = true
			}
		}

		if !commandExists {
			err := os.RemoveAll(templateDir)
			if err != nil {
				return err
			}

			fmt.Printf("Removed templates at: templates/%s\n", filepath.Base(templateDir))
		}
	}

	return nil
}

func (g *Generator) createCommandTemplates(command string, commandTemplateDir string, fileTemplates map[string]string) error {
	for fileName, template := range fileTemplates {
		f, err := os.Create(filepath.Join(commandTemplateDir, fileName))
		if err != nil {
			if strings.Contains(err.Error(), "file exists") {
				continue
			}

			return err
		}

		if template != "" {
			_, err = f.Write([]byte(fmt.Sprintf(template, command)))
			if err != nil {
				return err
			}

			err = f.Close()
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *Generator) getTemplatesDirectoryContents(onlyDirectories bool) ([]string, error) {
	var templateDirs []string
	err := filepath.Walk(g.templatesDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if path == g.templatesDir {
			return nil
		}

		if !onlyDirectories || info.IsDir() {
			templateDirs = append(templateDirs, path)
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return templateDirs, nil
}

func getFileContents(filepath string) (string, error) {
	contents, err := ioutil.ReadFile(filepath)
	if err != nil {
		return "", err
	}

	return string(contents), nil
}
