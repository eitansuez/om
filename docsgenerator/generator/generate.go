package generator

import (
	"fmt"
	"github.com/pivotal-cf/om/docsgenerator/executor"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

const (
	ReadmeFileName         = "README.md"
	ReadmeTemplate         = "<!--- This file is autogenerated from the files in docsgenerator/templates/%s --->\n&larr; [back to Commands](../README.md)\n\n# `om %s`\n\n%s\n\n## Command Usage\n```\n%s```\n\n%s"
	DescriptionFileName    = "EXPANDED_DESCRIPTION.md"
	DescriptionTemplate    = "<!--- Anything in this file will be used instead of the default command description in the final docs/%s/README.md file --->"
	additionalInfoFileName = "ADDITIONAL_INFO.md"
	AdditionalInfoTemplate = "<!--- Anything in this file will be appended to the final docs/%s/README.md file --->"
)

type Generator struct {
	omPath        string
	templatesPath string
	docsDir       string
	executor      executor.Executor
}

func NewGenerator(omPath string, templatesPath string, docsDir string, executor executor.Executor) Generator {
	return Generator{
		omPath:        omPath,
		templatesPath: templatesPath,
		docsDir:       docsDir,
		executor:      executor,
	}
}

func (g *Generator) GenerateDocs() error {
	commandNames, err := g.executor.GetCommandNames()
	if err != nil {
		return err
	}

	err = g.createTemplateDirs(commandNames)
	if err != nil {
		return err
	}

	templateDirs, err := g.getTemplatesDirectoryContents(true)
	if err != nil {
		return err
	}

	for _, templateDir := range templateDirs {
		commandName := filepath.Base(templateDir)

		descriptionContents, err := getFileContents(filepath.Join(templateDir, DescriptionFileName))
		if err != nil {
			return err
		}

		additionalInfoContents, err := getFileContents(filepath.Join(templateDir, additionalInfoFileName))
		if err != nil {
			return err
		}

		err = os.Mkdir(filepath.Join(g.docsDir, commandName), 0755)
		if err != nil && !strings.Contains(err.Error(), "file exists") {
			return err
		}

		f, err := os.Create(filepath.Join(g.docsDir, commandName, ReadmeFileName))
		if err != nil && !strings.Contains(err.Error(), "file exists") {
			return err
		}

		if len(strings.Split(descriptionContents, "\n")) == 1 && descriptionContents == fmt.Sprintf(DescriptionTemplate, commandName) {
			descriptionContents, err = g.executor.GetDescription(commandName)
			if err != nil {
				return err
			}
		}

		if len(strings.Split(additionalInfoContents, "\n")) == 1 && additionalInfoContents == fmt.Sprintf(AdditionalInfoTemplate, commandName) {
			additionalInfoContents = ""
		}

		usage, err := g.executor.GetCommandHelp(commandName)
		if err != nil {
			return err
		}

		_, err = f.Write([]byte(fmt.Sprintf(ReadmeTemplate, commandName, commandName, descriptionContents, usage, additionalInfoContents)))
		if err != nil {
			return err
		}

		err = f.Close()
		if err != nil {
			return err
		}
	}

	return nil
}

func (g *Generator) createTemplateDirs(commands []string) error {
	templateDirs, err := g.getTemplatesDirectoryContents(true)
	if err != nil {
		return err
	}

	for _, command := range commands {
		err = os.Mkdir(filepath.Join(g.templatesPath, command), 0755)
		if err != nil {
			if strings.Contains(err.Error(), "file exists") {
				continue
			}

			return err
		}

		commandTemplateDir := filepath.Join(g.templatesPath, command)

		err := g.createCommandTemplates(command, commandTemplateDir, map[string]string{
			additionalInfoFileName: AdditionalInfoTemplate,
			DescriptionFileName:    DescriptionTemplate,
		})
		if err != nil {
			return err
		}

		fmt.Printf("Added %s templates at: docsgenerator%s\n", command, strings.Split(commandTemplateDir, "docsgenerator")[1])
	}

	for _, templateDir := range templateDirs {
		var commandExists bool
		for _, command := range commands {
			if strings.Contains(templateDir, command) {
				commandExists = true
			}
		}

		if !commandExists {
			err := os.RemoveAll(templateDir)
			if err != nil {
				return err
			}

			fmt.Printf("Removed templates at: docsgenerator/templates%s\n", strings.Split(templateDir, "templates")[1])
		}
	}

	return nil
}

func (g *Generator) createCommandTemplates(command string, commandTemplateDir string, fileTemplates map[string]string) error {
	for fileName, template := range fileTemplates {
		f, err := os.Create(filepath.Join(commandTemplateDir, fileName))
		if err != nil {
			if strings.Contains(err.Error(), "file exists") {
				continue
			}

			return err
		}

		if template != "" {
			_, err = f.Write([]byte(fmt.Sprintf(template, command)))
			if err != nil {
				return err
			}

			err = f.Close()
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *Generator) getTemplatesDirectoryContents(onlyDirectories bool) ([]string, error) {
	var templateDirs []string
	err := filepath.Walk(g.templatesPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if path == g.templatesPath {
			return nil
		}

		if !onlyDirectories || info.IsDir() {
			templateDirs = append(templateDirs, path)
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	return templateDirs, nil
}

func getFileContents(filepath string) (string, error) {
	contents, err := ioutil.ReadFile(filepath)
	if err != nil {
		return "", err
	}

	return string(contents), nil
}
